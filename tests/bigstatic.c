/* 
   Tests data in .bss or .data sections 
   over 1 page (4k)
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SAMPLES 0x1000000


static void big_text()
{
  printf("%d\n", 0x1919);

  printf("USAGE:\n");
  printf("       <Inputimage (BMP|PPM)> <Quality or PSV> [options]\n\n");
  printf("\n");
  printf("       <Inputimage (JPG)> [options]\n");

  printf("\nGENERAL OPTIONS\n");
  printf("---------------\n");
  printf("-alloc = Dynamically allocate JPEG buffers\n");
  printf("-benchtime T = Run each benchmark for at least T seconds [default = 5.0]\n");
  printf("-bmp = Use Windows Bitmap format for output images [default = PPM]\n");
  printf("     ** 8-bit data precision only **\n");
  printf("-bottomup = Use bottom-up row order for packed-pixel source/destination buffers\n");
  printf("-componly = Stop after running compression tests.  Do not test decompression.\n");
  printf("-lossless = Generate lossless JPEG images when compressing (implies\n");
  printf("     -subsamp 444).  PSV is the predictor selection value (1-7).\n");
  printf("-nowrite = Do not write reference or output images (improves consistency of\n");
  printf("     benchmark results)\n");
  printf("-rgb, -bgr, -rgbx, -bgrx, -xbgr, -xrgb =\n");
  printf("     Use the specified pixel format for packed-pixel source/destination buffers\n");
  printf("     [default = BGR]\n");
  printf("-cmyk = Indirectly test YCCK JPEG compression/decompression\n");
  printf("     (use the CMYK pixel format for packed-pixel source/destination buffers)\n");
  printf("-precision N = Use N-bit data precision when compressing [N is 8, 12, or 16;\n");
  printf("     default = 8; if N is 16, then -lossless must also be specified]\n");
  printf("     (-precision 12 implies -optimize unless -arithmetic is also specified)\n");
  printf("-quiet = Output results in tabular rather than verbose format\n");
  printf("-restart N = When compressing, add a restart marker every N MCU rows (lossy) or\n");
  printf("     N sample rows (lossless) [default = 0 (no restart markers)].  Append 'B'\n");
  printf("     to specify the restart marker interval in MCU blocks (lossy) or samples\n");
  printf("     (lossless).\n");
  printf("-stoponwarning = Immediately discontinue the current\n");
  printf("     compression/decompression/transform operation if a warning (non-fatal\n");
  printf("     error) occurs\n");
  printf("-tile = Compress/transform the input image into separate JPEG tiles of varying\n");
  printf("     sizes (useful for measuring JPEG overhead)\n");
  printf("-warmup T = Run each benchmark for T seconds [default = 1.0] prior to starting\n");
  printf("     the timer, in order to prime the caches and thus improve the consistency\n");
  printf("     of the benchmark results\n");

  printf("\nLOSSY JPEG OPTIONS\n");
  printf("------------------\n");
  printf("-arithmetic = Use arithmetic entropy coding in JPEG images generated by\n");
  printf("     compression and transform operations (can be combined with -progressive)\n");
  printf("-crop WxH+X+Y = Decompress only the specified region of the JPEG image, where W\n");
  printf("     and H are the width and height of the region (0 = maximum possible width\n");
  printf("     or height) and X and Y are the left and upper boundary of the region, all\n");
  printf("     specified relative to the scaled image dimensions.  X must be divible by\n");
  printf("     the scaled MCU width.\n");
  printf("-fastdct = Use the fastest DCT/IDCT algorithm available\n");
  printf("-fastupsample = Use the fastest chrominance upsampling algorithm available\n");
  printf("-optimize = Use optimized baseline entropy coding in JPEG images generated by\n");
  printf("     compession and transform operations\n");
  printf("-progressive = Use progressive entropy coding in JPEG images generated by\n");
  printf("     compression and transform operations (can be combined with -arithmetic;\n");
  printf("     implies -optimize unless -arithmetic is also specified)\n");
  printf("-limitscans = Refuse to decompress or transform progressive JPEG images that\n");
  printf("     have an unreasonably large number of scans\n");
  printf("-scale M/N = When decompressing, scale the width/height of the JPEG image by a\n");
  printf("     factor of M/N (M/N = ");

  printf(")\n");
  printf("-subsamp S = When compressing, use the specified level of chrominance\n");
  printf("     subsampling (S = 444, 422, 440, 420, 411, 441, or GRAY) [default = test\n");
  printf("     Grayscale, 4:2:0, 4:2:2, and 4:4:4 in sequence]\n");
  printf("-hflip, -vflip, -transpose, -transverse, -rot90, -rot180, -rot270 =\n");
  printf("     Perform the specified lossless transform operation on the input image\n");
  printf("     prior to decompression (these operations are mutually exclusive)\n");
  printf("-grayscale = Transform the input image into a grayscale JPEG image prior to\n");
  printf("     decompression (can be combined with the other transform operations above)\n");

  printf("----- %d\n", 0x1919);

  printf("-copynone = Do not copy any extra markers (including EXIF and ICC profile data)\n");
  printf("     when transforming the input image\n");
  printf("-yuv = Compress from/decompress to intermediate planar YUV images\n");
  printf("     ** 8-bit data precision only **\n");
  printf("-yuvpad N = The number of bytes by which each row in each plane of an\n");
  printf("     intermediate YUV image is evenly divisible (N must be a power of 2)\n");
  printf("     [default = 1]\n");

  printf("\nNOTE:  If the quality/PSV is specified as a range (e.g. 90-100 or 1-4), a\n");
  printf("separate test will be performed for all values in the range.\n\n");
}

void big_bss()
{
    static size_t values[MAX_SAMPLES];
    static size_t sorted[MAX_SAMPLES]; 
    static size_t ref[MAX_SAMPLES];

    printf("bigger %lx %d\n", MAX_SAMPLES, 0x1919);
    printf("1 %lx\n", values);
    printf("2 %lx\n", sorted);
    printf("3 %lx\n", ref);

    memset(values, 0, sizeof(values));
    memset(sorted, 0, sizeof(sorted));
    memset(ref, 0, sizeof(ref));
}

int main(void)
{
    big_bss();
    big_text();

    return 0;
}
